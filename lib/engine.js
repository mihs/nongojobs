// Generated by CoffeeScript 1.6.3
(function() {
  var Engine, EventEmitter, MongoClient, Server, debug, initialId, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  MongoClient = require("mongodb").MongoClient;

  Server = require('mongodb').Server;

  debug = require("debug")("nongojobs:engine");

  util = require("util");

  EventEmitter = require("events").EventEmitter;

  initialId = new mongo.ObjectID("000000000000000000000000");

  module.exports = Engine = (function(_super) {
    __extends(Engine, _super);

    function Engine(options) {
      this.start = __bind(this.start, this);
      this.options = options || {};
      this.running = false;
      this.maxJobs = this.options.maxJobs || 5;
      this.colName = options.colName;
      this.jobs = 0;
      this.subscribers = {};
    }

    Engine.prototype.ensureConnection = function(callback) {
      var _this = this;
      if (this._db) {
        return process.nextTick(function() {
          return callback(null, this._db);
        });
      } else if (!this.options.db) {
        return process.nextTick(function() {
          return callback(new Error("Database connection information required"));
        });
      } else if (typeof this.options.db === "object") {
        this._db = this.options.db;
        return process.nextTick(function() {
          return callback(null, this._db);
        });
      } else if (typeof this.options.db === "string") {
        return MongoClient.connect(this.options.db, this.options.dbOptions(function(err, db) {
          if (err) {
            return callback(err);
          }
          _this._db = db;
          return callback(null, _this._db);
        }));
      } else {
        return process.nextTick(function() {
          return callback(new Error("Invalid database connection information"));
        });
      }
    };

    Engine.prototype.cleanup = function(job, callback) {
      return this._db.collection(this.options.dbCollection).update({
        _id: job._id
      }, {
        $set: {
          finished: true,
          locked: false
        }
      }, function(err, result) {
        if (err) {
          this.emit("error", err);
        }
        return typeof callback === "function" ? callback() : void 0;
      });
    };

    Engine.prototype.unlock = function(job, status, callback) {
      if (typeof status === "function") {
        callback = status;
        status = {};
      }
      if (status == null) {
        status = {};
      }
      status.locked = false;
      return this._db.collection(this.options.dbCollection).findAndModify({
        _id: job._id,
        locked: true
      }, [], {
        $set: {
          status: status
        }
      }, function(err, job) {
        if (err) {
          this.emit("error", err);
        }
        return typeof callback === "function" ? callback() : void 0;
      });
    };

    Engine.prototype.update = function(job, status, callback) {
      if (typeof status === "function") {
        callback = status;
        status = {};
      }
      return this._db.collection(this.options.dbCollection).update({
        _id: job._id
      }, {
        $set: {
          status: status
        }
      }, function(err, job) {
        if (err) {
          this.emit("error", err);
        }
        return typeof callback === "function" ? callback() : void 0;
      });
    };

    Engine.prototype.start = function() {
      var afterJob, check, from,
        _this = this;
      if (this.stopping) {
        return debug("Stopping, will not run");
      }
      if (this.running) {
        return debug("Already started");
      }
      this.running = true;
      debug("running = true");
      from = initialId;
      afterJob = function() {
        _this.jobs--;
        debug("#jobs = %d", _this.jobs);
        if (_this.jobs === 0 && _this.stopping) {
          return _this.emit("stop");
        }
        if (_this.jobs < _this.maxJobs && !_this.stopping) {
          return process.nextTick(check);
        }
      };
      check = function() {
        if (_this.stopping) {
          _this.running = false;
          debug("running = false");
          return;
        }
        return _this._db.collection(_this.options.dbCollection).findAndModify({
          locked: false,
          finished: false,
          _id: {
            $gt: from
          }
        }, [], {
          $set: {
            locked: true
          }
        }, {
          "new": true
        }, function(err, job) {
          if (err) {
            _this.running = false;
            debug("running = false");
            _this.emit("error", err);
            return;
          }
          if (job) {
            from = job._id;
            if (_this.stopping) {
              _this.unlock(job);
              return;
            }
            _this.jobs++;
            debug("Found job %j, #jobs = %d", util.inspect(job), _this.jobs);
            _this.process(job, function(err, result) {
              var error;
              if (err) {
                _this.emit("error", err);
                error = {
                  message: err.message || err,
                  stack: err.stack || ""
                };
                if (result != null ? result.retry : void 0) {
                  debug("Unlocking up %j", job);
                  return _this.unlock(job, {
                    error: error
                  }, afterJob);
                } else {
                  return _this.update(job, {
                    error: error
                  }, afterJob);
                }
              } else if (!(result != null ? result.keep : void 0)) {
                debug("Cleaning up %j", job);
                return _this.cleanup(job, afterJob);
              }
            });
            if (_this.jobs < _this.maxJobs && !_this.stopping) {
              return process.nextTick(check);
            }
          } else {
            _this.running = false;
            debug("running = false");
            if (_this.jobs === 0 && _this.stopping) {
              return _this.emit("stop");
            }
          }
        });
      };
      return this.ensureConnection(function(err) {
        if (err) {
          return this.emit(err);
        }
        return check();
      });
    };

    Engine.prototype.stop = function() {
      if (!this.stopping) {
        this.stopping = true;
        if (this.jobs === 0) {
          return this.emit("stop");
        }
      }
    };

    Engine.prototype.process = function(job, callback) {
      if (this.subscribers[job.type]) {
        debug("Forwarding %s to subscriber", job.type);
        return this.subscribers[job.type](job, callback);
      } else {
        return process.nextTick(callback);
      }
    };

    return Engine;

  })(EventEmitter);

}).call(this);
